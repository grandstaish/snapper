/*
 * Copyright (C) 2018 Square, Inc.
 * Modifications (C) 2018 Bradley Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package nz.bradcampbell.snapper.compiler

import com.squareup.kotlinpoet.ARRAY
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.NameAllocator
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.TypeVariableName
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.asTypeName
import me.eugeniomarletti.kotlin.metadata.isDataClass
import me.eugeniomarletti.kotlin.metadata.shadow.metadata.ProtoBuf.Visibility
import me.eugeniomarletti.kotlin.metadata.visibility
import nz.bradcampbell.snapper.Serializer
import nz.bradcampbell.snapper.Snapper
import okio.BufferedSink
import okio.BufferedSource
import java.lang.reflect.Type

internal class SerializerGenerator(
    target: TargetType,
    private val propertyList: List<PropertyGenerator>
) {
  private val className = target.name
  private val isDataClass = target.proto.isDataClass
  private val companionObjectName = target.companionObjectName
  private val visibility = target.proto.visibility!!
  private val typeVariables = target.typeVariables

  private val nameAllocator = NameAllocator()
  private val serializerName = "${className.simpleNames.joinToString(separator = "_")}Serializer"
  private val originalTypeName = target.element.asType().asTypeName()

  private val snapperParam = ParameterSpec.builder(
      nameAllocator.newName("snapper"),
      Snapper::class).build()
  private val typesParam = ParameterSpec.builder(
      nameAllocator.newName("types"),
      ARRAY.parameterizedBy(Type::class.asTypeName()))
      .build()
  private val sourceParam = ParameterSpec.builder(
      nameAllocator.newName("source"),
      BufferedSource::class)
      .build()
  private val sinkParam = ParameterSpec.builder(
      nameAllocator.newName("sink"),
      BufferedSink::class)
      .build()
  private val valueParam = ParameterSpec.builder(
      nameAllocator.newName("value"),
      originalTypeName)
      .build()
  private val serializerTypeName = Serializer::class.asClassName().parameterizedBy(originalTypeName)

  fun generateFile(): FileSpec {
    for (property in propertyList) {
      property.allocateNames(nameAllocator)
    }
    val result = FileSpec.builder(className.packageName, serializerName)
    result.addComment("Code generated by snapper-compiler. Do not edit.")
    companionObjectName?.let {
      result.addFunction(generateSerializerFun(it))
    }
    result.addType(generateType())
    return result.build()
  }

  private fun generateType(): TypeSpec {
    val result = TypeSpec.classBuilder(serializerName)

    result.superclass(serializerTypeName)

    if (typeVariables.isNotEmpty()) {
      result.addTypeVariables(typeVariables)
    }

    // TODO make this configurable. Right now it just matches the source model
    if (visibility == Visibility.INTERNAL) {
      result.addModifiers(KModifier.INTERNAL)
    }

    result.primaryConstructor(generateConstructor())

    val typeRenderer: TypeRenderer = object : TypeRenderer() {
      override fun renderTypeVariable(typeVariable: TypeVariableName): CodeBlock {
        val index = typeVariables.indexOfFirst { it == typeVariable }
        check(index != -1) { "Unexpected type variable $typeVariable" }
        return CodeBlock.of("%N[%L]", typesParam, index)
      }
    }

    for (uniqueSerializer in propertyList.distinctBy { it.delegateKey }) {
      result.addProperty(uniqueSerializer.delegateKey.generateProperty(
          nameAllocator, typeRenderer, snapperParam))
    }

    result.addFunction(generateToStringFun())
    result.addFunction(generateWriteFun())
    result.addFunction(generateReadFun())

    return result.build()
  }

  private fun generateConstructor(): FunSpec {
    val result = FunSpec.constructorBuilder()
    result.addParameter(snapperParam)

    if (typeVariables.isNotEmpty()) {
      result.addParameter(typesParam)
    }

    return result.build()
  }

  private fun generateToStringFun(): FunSpec {
    return FunSpec.builder("toString")
        .addModifiers(KModifier.OVERRIDE)
        .returns(String::class)
        .addStatement("return %S",
            "GeneratedSerializer(${originalTypeName.rawType().simpleNames.joinToString(".")})")
        .build()
  }

  private fun generateWriteFun(): FunSpec {
    val result = FunSpec.builder("write")
        .addModifiers(KModifier.OVERRIDE)
        .addParameter(sinkParam)
        .addParameter(valueParam)

    propertyList.forEach { property ->
      result.addStatement("%N.write(%N, %N.%L)", nameAllocator.get(property.delegateKey),
          sinkParam, valueParam, property.name)
    }

    return result.build()
  }

  private fun generateReadFun(): FunSpec {
    val resultName = nameAllocator.newName("result")

    val result = FunSpec.builder("read")
        .addModifiers(KModifier.OVERRIDE)
        .addParameter(sourceParam)
        .returns(originalTypeName)

    for (property in propertyList) {
      result.addCode("%L", property.generateLocalProperty())
      if (property.differentiateAbsentFromNull) {
        result.addCode("%L", property.generateLocalIsPresentProperty())
      }
    }

    propertyList.forEach { property ->
      result.addStatement("%L = %N.read(%N)", property.localName,
          nameAllocator.get(property.delegateKey), sourceParam)
    }

    // Call the constructor providing only required parameters.
    var hasOptionalParameters = false
    result.addCode("%[var %N = %T(", resultName, originalTypeName)
    var separator = "\n"
    for (property in propertyList) {
      if (!property.hasConstructorParameter) {
        continue
      }
      if (property.hasDefault) {
        hasOptionalParameters = true
        continue
      }
      result.addCode(separator)
      result.addCode("%N = %N", property.name, property.localName)
      separator = ",\n"
    }
    result.addCode(")%]\n", originalTypeName)

    // Call either the constructor again, or the copy() method, this time providing any optional
    // parameters that we have.
    if (hasOptionalParameters) {
      if (isDataClass) {
        result.addCode("%[%1N = %1N.copy(", resultName)
      } else {
        result.addCode("%[%1N = %2T(", resultName, originalTypeName)
      }
      separator = "\n"
      for (property in propertyList) {
        if (!property.hasConstructorParameter) {
          continue // No constructor parameter for this property.
        }
        if (isDataClass && !property.hasDefault) {
          continue // Property already assigned.
        }

        result.addCode(separator)
        if (property.differentiateAbsentFromNull) {
          result.addCode("%2N = if (%3N) %4N else %1N.%2N",
              resultName, property.name, property.localIsPresentName, property.localName)
        } else {
          result.addCode("%2N = %3N ?: %1N.%2N", resultName, property.name, property.localName)
        }
        separator = ",\n"
      }
      result.addCode("%])\n")
    }

    // Assign properties not present in the constructor.
    for (property in propertyList) {
      if (property.hasConstructorParameter) {
        continue // Property already handled.
      }
      if (property.differentiateAbsentFromNull) {
        result.addStatement("%1N.%2N = if (%3N) %4N else %1N.%2N",
            resultName, property.name, property.localIsPresentName, property.localName)
      } else {
        result.addStatement("%1N.%2N = %3N ?: %1N.%2N",
            resultName, property.name, property.localName)
      }
    }

    result.addStatement("return %1N", resultName)
    return result.build()
  }

  private fun generateSerializerFun(name: String): FunSpec {
    val rawType = when (originalTypeName) {
      is TypeVariableName -> throw IllegalArgumentException("Cannot get raw type of TypeVariable!")
      is ParameterizedTypeName -> originalTypeName.rawType
      else -> originalTypeName as ClassName
    }

    val result = FunSpec.builder("serializer")
        .receiver(rawType.nestedClass(name))
        .returns(serializerTypeName)
        .addParameter(snapperParam)

    if (visibility == Visibility.INTERNAL) {
      result.addModifiers(KModifier.INTERNAL)
    }

    if (typeVariables.isNotEmpty()) {
      result.addParameter(typesParam)
      result.addTypeVariables(typeVariables)
      result.addStatement("return %N(%N, %N)", serializerName, snapperParam, typesParam)
    } else {
      result.addStatement("return %N(%N)", serializerName, snapperParam)
    }

    return result.build()
  }
}
